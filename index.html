<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Three.js GLTFLoader and DRACOLoader for advanced model loading -->
    <script src="https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.158.0/examples/jsm/loaders/DRACOLoader.js"></script>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <!-- Th√™m script cho aframe-html-shader -->
    <script src="https://unpkg.com/aframe-html-shader@0.2.0/dist/aframe-html-shader.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
            font-size: 1.2em;
        }

        a-scene {
            display: block;
            width: 100%;
            height: 100%;
        }

        #loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            /* Ensure it's above the scene */
        }

        #loading-message::after {
            content: '';
            animation: ellipsis 1.2s infinite;
        }

        @keyframes ellipsis {
            0% {
                content: '.';
            }

            33% {
                content: '..';
            }

            66% {
                content: '...';
            }

            100% {
                content: '';
            }
        }

        .progress-bar {
            position: absolute;
            top: calc(50% + 30px);
            /* Position below loading message */
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
            z-index: 10;
            /* Ensure it's above the scene */
        }

        .progress-fill {
            height: 100%;
            background: #3498db;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* CSS cho c√°c ph·∫ßn t·ª≠ HTML ƒë∆∞·ª£c nh√∫ng */
        .info-panel-content {
            width: 300px;
            /* Chi·ªÅu r·ªông c·ªßa panel */
            height: 250px;
            /* ƒê√£ tƒÉng chi·ªÅu cao ƒë·ªÉ c√≥ th√™m kh√¥ng gian cho m√¥ t·∫£ */
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            /* ƒê√£ thay ƒë·ªïi ƒë·ªÉ cƒÉn ch·ªânh n·ªôi dung t·ª´ tr√™n xu·ªëng */
            align-items: center;
            text-align: center;
            color: #FFFF00;
            /* ƒê√£ thay ƒë·ªïi m√†u ch·ªØ th√†nh v√†ng */
            font-family: 'Roboto', sans-serif;
            /* S·ª≠ d·ª•ng font h·ªó tr·ª£ ti·∫øng Vi·ªát */
            font-size: 24px;
            /* ƒê√£ tƒÉng k√≠ch th∆∞·ªõc font */
            line-height: 1.4;
            /* overflow: auto; */
            /* T·∫°m th·ªùi b·ªè overflow ƒë·ªÉ th·∫•y to√†n b·ªô n·ªôi dung */
            background-color: #FF0000;
            /* ƒê√£ thay ƒë·ªïi m√†u n·ªÅn th√†nh ƒê·ªé ƒë·ªÉ d·ªÖ debug */
            border-radius: 8px;
            /* Th√™m bo g√≥c cho ƒë·∫πp */
        }

        .info-panel-content h3 {
            margin: 0 0 10px 0;
            font-size: 28px;
            /* ƒê√£ tƒÉng k√≠ch th∆∞·ªõc font */
            font-weight: bold;
        }

        .info-panel-content p {
            margin: 0;
            font-size: 20px;
            /* ƒê√£ tƒÉng k√≠ch th∆∞·ªõc font */
        }

        .instructions-text {
            width: 300px;
            text-align: center;
            color: #00FF00;
            /* ƒê√£ thay ƒë·ªïi m√†u ch·ªØ th√†nh xanh l√° c√¢y */
            font-family: 'Roboto', sans-serif;
            font-size: 20px;
            /* ƒê√£ tƒÉng k√≠ch th∆∞·ªõc font */
            margin-top: 10px;
            background-color: #0000FF;
            /* ƒê√£ thay ƒë·ªïi m√†u n·ªÅn th√†nh XANH D∆Ø∆†NG */
            padding: 5px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <div id="loading-message">ƒêang t·∫£i d·ªØ li·ªáu AR...</div>
    <div id="progress-container" class="progress-bar" style="display: none;">
        <div id="progress-fill" class="progress-fill"></div>
    </div>

    <a-scene embedded vr-mode-ui="enabled: false">
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

        <!-- ENTITY TEST HTML-SHADER T·ªêI GI·∫¢N -->
        <a-entity position="0 0 -2" scale="0.02 0.02 0.02" look-at="[camera]" render-order="99" html-shader="
                    html: <div style='width: 400px; height: 150px; background-color: #00FFFF; color: #FF00FF; text-align: center; padding: 20px; font-size: 30px; font-family: sans-serif;'>
                            TEST HTML-SHADER
                          </div>;
                    transparent: true;
                    shader: html;
                    targetWidth: 400;
                    targetHeight: 150;
                    debug: true;
                    side: double;
                    depthTest: false;
                ">
        </a-entity>
        <!-- K·∫æT TH√öC ENTITY TEST -->

        <!-- Th√™m m·ªôt h·ªôp ƒë∆°n gi·∫£n ƒë·ªÉ ki·ªÉm tra xem c·∫£nh c√≥ hi·ªÉn th·ªã kh√¥ng -->
        <a-box position="0 0 -3" color="green" width="0.5" height="0.5" depth="0.5"></a-box>

    </a-scene>

    <script>
        // LOD (Level of Detail) component
        AFRAME.registerComponent('lod-system', {
            schema: {
                distances: { type: 'array', default: [5, 15, 30] }, // Distances for high, medium, low quality
                qualities: { type: 'array', default: ['high', 'medium', 'low'] }
            },

            init: function () {
                this.camera = document.querySelector('[camera]');
                this.lastDistance = 0;
                this.currentLOD = 'high';

                // Throttle distance checking to improve performance
                this.checkDistance = this.throttle(this.checkDistance.bind(this), 200);
            },

            tick: function () {
                // Only check distance if the model is visible
                if (this.el.object3D.visible) {
                    this.checkDistance();
                }
            },

            checkDistance: function () {
                if (!this.camera || !this.el.object3D) return;

                const distance = this.el.object3D.position.distanceTo(this.camera.object3D.position);

                // Update LOD only if distance changes significantly
                if (Math.abs(distance - this.lastDistance) > 2) {
                    this.lastDistance = distance;
                    this.updateLOD(distance);
                }
            },

            updateLOD: function (distance) {
                let newLOD = 'high';

                if (distance > this.data.distances[2]) {
                    newLOD = 'low';
                } else if (distance > this.data.distances[1]) {
                    newLOD = 'medium';
                }

                if (newLOD !== this.currentLOD) {
                    this.currentLOD = newLOD;
                    this.applyLOD(newLOD);
                }
            },

            applyLOD: function (level) {
                const model = this.el.object3D;

                model.traverse((child) => {
                    if (child.isMesh && child.material) {
                        switch (level) {
                            case 'low':
                                child.material.precision = 'lowp';
                                // Optionally hide less important parts of the model
                                child.visible = child.userData.isImportant !== false;
                                break;
                            case 'medium':
                                child.material.precision = 'mediump';
                                child.visible = true;
                                break;
                            case 'high':
                                child.material.precision = 'highp';
                                child.visible = true;
                                break;
                        }
                        // Ensure material updates are applied
                        child.material.needsUpdate = true;
                    }
                });
            },

            throttle: function (func, limit) {
                let inThrottle;
                return function () {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }
        });

        // Optimized interactive model component (Pan and Zoom only, no rotation)
        AFRAME.registerComponent('interactive-model', {
            schema: {
                minScale: { type: 'number', default: 0.0001 },
                maxScale: { type: 'number', default: 0.0005 },
                panSpeed: { type: 'number', default: 0.0008 },
                zoomSpeed: { type: 'number', default: 0.00003 }
            },

            init: function () {
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                this.initialPinchDistance = null; // For two-finger zoom

                const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const throttleDelay = isMobile ? 32 : 16; // More aggressive throttling for mobile

                this.throttledMouseMove = this.throttle(this.onMouseMove.bind(this), throttleDelay);

                this.onMouseDown = this.onMouseDown.bind(this);
                this.onMouseUp = this.onMouseUp.bind(this);
                this.onMouseWheel = this.onMouseWheel.bind(this);

                this.onTouchStart = this.onTouchStart.bind(this);
                this.onTouchEnd = this.onTouchEnd.bind(this);
                this.onTouchMove = this.throttle(this.onTouchMove.bind(this), throttleDelay);

                this.el.addEventListener('mousedown', this.onMouseDown);
                this.el.addEventListener('mouseup', this.onMouseUp);
                this.el.addEventListener('mousemove', this.throttledMouseMove);
                this.el.addEventListener('wheel', this.onMouseWheel);

                this.el.addEventListener('touchstart', this.onTouchStart);
                this.el.addEventListener('touchend', this.onTouchEnd);
                this.el.addEventListener('touchmove', this.onTouchMove);
            },

            throttle: function (func, limit) {
                let inThrottle;
                return function () {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            },

            onTouchStart: function (evt) {
                if (evt.touches.length === 1) {
                    this.isDragging = true;
                    this.lastX = evt.touches[0].clientX;
                    this.lastY = evt.touches[0].clientY;
                } else if (evt.touches.length === 2) {
                    this.isDragging = true;
                    this.lastX = (evt.touches[0].clientX + evt.touches[1].clientX) / 2;
                    this.lastY = (evt.touches[0].clientY + evt.touches[1].clientY) / 2;
                    this.initialPinchDistance = Math.hypot(
                        evt.touches[0].clientX - evt.touches[1].clientX,
                        evt.touches[0].clientY - evt.touches[1].clientY
                    );
                }
            },

            onTouchEnd: function () {
                this.isDragging = false;
                this.initialPinchDistance = null;
            },

            onTouchMove: function (evt) {
                if (!this.isDragging) return;

                evt.preventDefault(); // Prevent scrolling

                if (evt.touches.length === 1) {
                    const touch = evt.touches[0];
                    const deltaX = touch.clientX - this.lastX;
                    const deltaY = touch.clientY - this.lastY;
                    this.applyPan(deltaX, deltaY);
                    this.lastX = touch.clientX;
                    this.lastY = touch.clientY;
                } else if (evt.touches.length === 2) {
                    const touch1 = evt.touches[0];
                    const touch2 = evt.touches[1];

                    // Pan with two fingers
                    const currentX = (touch1.clientX + touch2.clientX) / 2;
                    const currentY = (touch1.clientY + touch2.clientY) / 2;
                    const deltaX = currentX - this.lastX;
                    const deltaY = currentY - this.lastY;
                    this.applyPan(deltaX, deltaY);
                    this.lastX = currentX;
                    this.lastY = currentY;

                    // Zoom with pinch
                    const currentPinchDistance = Math.hypot(
                        touch1.clientX - touch2.clientX,
                        touch1.clientY - touch2.clientY
                    );
                    if (this.initialPinchDistance) {
                        const scaleFactor = currentPinchDistance / this.initialPinchDistance;
                        let newScale = this.el.object3D.scale.x - evt.deltaY * this.data.zoomSpeed;
                        newScale = Math.max(this.data.minScale, Math.min(this.data.maxScale, newScale));
                        this.el.object3D.scale.set(newScale, newScale, newScale);
                        this.initialPinchDistance = currentPinchDistance; // Update for next move
                    }
                }
            },

            onMouseDown: function (evt) {
                this.isDragging = true;
                this.lastX = evt.clientX;
                this.lastY = evt.clientY;
            },

            onMouseUp: function () {
                this.isDragging = false;
            },

            onMouseMove: function (evt) {
                if (!this.isDragging) return;

                const deltaX = evt.clientX - this.lastX;
                const deltaY = evt.clientY - this.lastY;

                // Always pan on mouse drag (no rotation)
                this.applyPan(deltaX, deltaY);

                this.lastX = evt.clientX;
                this.lastY = evt.clientY;
            },

            applyPan: function (deltaX, deltaY) {
                const currentPos = this.el.object3D.position;
                currentPos.x += deltaX * this.data.panSpeed;
                currentPos.y -= deltaY * this.data.panSpeed;

                // Clamping logic for panning (adjusted for right-side model position)
                const parentWidth = 0.6; // Adjusted for right side
                const parentHeight = 0.9;
                const modelScale = this.el.object3D.scale.x;
                const modelHalfSize = modelScale * 15;

                const clampX = Math.max(0, (parentWidth / 2) - modelHalfSize);
                const clampY = Math.max(0, (parentHeight / 2) - modelHalfSize);

                const offsetX = 0.2; // Offset to keep model on the right side
                currentPos.x = Math.max(offsetX - clampX, Math.min(offsetX + clampX, currentPos.x));
                currentPos.y = Math.max(-clampY, Math.min(clampY, currentPos.y));
            },

            onMouseWheel: function (evt) {
                evt.preventDefault();

                let newScale = this.el.object3D.scale.x - evt.deltaY * this.data.zoomSpeed;
                newScale = Math.max(this.data.minScale, Math.min(this.data.maxScale, newScale));
                this.el.object3D.scale.set(newScale, newScale, newScale);
            },

            remove: function () {
                this.el.removeEventListener('mousedown', this.onMouseDown);
                this.el.removeEventListener('mouseup', this.onMouseUp);
                this.el.removeEventListener('mousemove', this.throttledMouseMove);
                this.el.removeEventListener('wheel', this.onMouseWheel);
                this.el.removeEventListener('touchstart', this.onTouchStart);
                this.el.removeEventListener('touchend', this.onTouchEnd);
                this.el.removeEventListener('touchmove', this.onTouchMove);
            }
        });

        // Model loading manager with progress and optimization
        class ModelLoadingManager {
            constructor() {
                this.loadingQueue = [];
                this.maxConcurrentLoads = 2; // Limit concurrent loads
                this.activeLoads = 0;
                this.cache = new Map(); // Using Map for LRU cache
                this.cacheSizeLimit = 2; // Limit cache to 2 most recent models
            }

            async loadModel(url, element, progressCallback) {
                // Check cache first
                if (this.cache.has(url)) {
                    const cachedModel = this.cache.get(url);
                    // Move to front of LRU (most recently used)
                    this.cache.delete(url);
                    this.cache.set(url, cachedModel, cachedModel);

                    element.setObject3D('mesh', cachedModel.clone());
                    if (progressCallback) progressCallback(100);
                    return;
                }

                return new Promise((resolve, reject) => {
                    this.loadingQueue.push({
                        url,
                        element,
                        progressCallback,
                        resolve,
                        reject
                    });

                    this.processQueue();
                });
            }

            async processQueue() {
                if (this.activeLoads >= this.maxConcurrentLoads || this.loadingQueue.length === 0) {
                    return;
                }

                const loadTask = this.loadingQueue.shift();
                this.activeLoads++;

                try {
                    await this.performLoad(loadTask);
                } catch (error) {
                    loadTask.reject(error);
                } finally {
                    this.activeLoads--;
                    this.processQueue(); // Process next in queue
                }
            }

            async performLoad(loadTask) {
                const { url, element, progressCallback, resolve, reject } = loadTask;

                const loader = new THREE.GLTFLoader();

                // Add Draco compression support for smaller files
                if (typeof THREE.DRACOLoader !== 'undefined') {
                    const dracoLoader = new THREE.DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                    loader.setDRACOLoader(dracoLoader);
                }

                // Removed loader.setWorkerLimit(4); to fix TypeError

                loader.load(
                    url,
                    (gltf) => {
                        // Optimize the loaded model
                        this.optimizeLoadedModel(gltf.scene);

                        // Manage LRU cache
                        if (this.cache.size >= this.cacheSizeLimit) {
                            // Delete the least recently used item (first item in Map)
                            const oldestUrl = this.cache.keys().next().value;
                            const oldestModel = this.cache.get(oldestUrl);
                            this.cache.delete(oldestUrl);
                            // Explicitly dispose of the model's resources
                            this.disposeModel(oldestModel);
                            console.log(`Cache: Removed and disposed oldest model: ${oldestUrl}`);
                        }
                        this.cache.set(url, gltf.scene); // Add new model to cache (becomes most recent)
                        console.log(`Cache: Added model: ${url}. Current cache size: ${this.cache.size}`);


                        // Set the model
                        element.setObject3D('mesh', gltf.scene);

                        if (progressCallback) progressCallback(100);
                        resolve(gltf);
                    },
                    (progress) => {
                        if (progressCallback && progress.lengthComputable) {
                            const percentComplete = (progress.loaded / progress.total) * 100;
                            progressCallback(percentComplete);
                        }
                    },
                    (error) => {
                        console.error('Model loading error:', error);
                        reject(error);
                    }
                );
            }

            optimizeLoadedModel(scene) {
                const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                scene.traverse((child) => {
                    if (child.isMesh) {
                        // Enable frustum culling
                        child.frustumCulled = true;

                        // Optimize geometry
                        if (child.geometry) {
                            child.geometry.computeBoundingBox();
                            child.geometry.computeBoundingSphere();

                            // Remove unnecessary vertex attributes for mobile
                            if (isMobile) {
                                if (child.geometry.attributes.uv2) {
                                    delete child.geometry.attributes.uv2;
                                }
                            }
                        }

                        // Optimize materials
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => this.optimizeMaterialForDevice(mat, isMobile));
                            } else {
                                this.optimizeMaterialForDevice(child.material, isMobile);
                            }
                        }
                    }
                });
            }

            optimizeMaterialForDevice(material, isMobile) {
                if (isMobile) {
                    material.precision = 'mediump';

                    // Reduce texture quality on mobile
                    if (material.map) {
                        material.map.generateMipmaps = true;
                        material.map.minFilter = THREE.LinearMipmapLinearFilter;
                        material.map.magFilter = THREE.LinearFilter;
                    }

                    // Disable expensive material features
                    material.fog = false;
                    material.receiveShadow = false;
                    material.castShadow = false;
                }
                // For desktop, keep higher quality settings if desired, or apply general optimizations
                material.alphaTest = 0.1; // Helps with transparent textures
                material.transparent = false; // Set to true only if actual transparency is needed
            }

            disposeModel(scene) {
                scene.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) {
                            child.geometry.dispose();
                        }
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });
            }
        }

        const modelLoadingManager = new ModelLoadingManager();

        // API Configuration
        const TOKEN_KEY = 'access_token';
        const EXPIRES_KEY = 'expires_in';
        const DATE_SAVE_KEY = 'date_save';
        // Default IMAGE_TARGET_SRC
        const DEFAULT_IMAGE_TARGET_SRC = 'https://u2502-dev.dttt.vn/static/assets//app/wwwroot/uploads/2025/6/13/1b387430-7f76-44a4-bdb8-5feb2f0e2d9f_dataAPPAr.mind';

        async function fetchNewToken() {
            const payload = new URLSearchParams({
                grant_type: 'password',
                scope: 'password',
                client_id: 'password',
                client_secret: '083c426a-a3f7-f4ea-a70a-290c401b558f',
                username: 'user3d',
                password: '123456a@A'
            });

            const res = await fetch('https://u2502-dev-sso.dttt.vn/connect/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: payload.toString()
            });

            if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Token fetch failed: ${res.status} ${res.statusText} - ${errorText}`);
            }

            const data = await res.json();
            localStorage.setItem(TOKEN_KEY, data.access_token);
            localStorage.setItem(EXPIRES_KEY, String(data.expires_in));
            localStorage.setItem(DATE_SAVE_KEY, String(Date.now()));
            return data.access_token;
        }

        function isTokenExpired() {
            const token = localStorage.getItem(TOKEN_KEY);
            const expiresIn = parseInt(localStorage.getItem(EXPIRES_KEY) || '0');
            const dateSaved = parseInt(localStorage.getItem(DATE_SAVE_KEY) || '0');
            if (!token || !expiresIn || !dateSaved) return true;
            const now = Date.now();
            const buffer = 5 * 24 * 60 * 60 * 1000; // 5 days buffer
            return now - dateSaved >= (expiresIn * 1000 - buffer);
        }

        async function getValidToken() {
            try {
                if (isTokenExpired()) {
                    console.log('üîÑ Token expired or missing, fetching new one...');
                    return await fetchNewToken();
                }
                console.log('‚úÖ Using saved token.');
                return localStorage.getItem(TOKEN_KEY) || "";
            } catch (e) {
                console.error('‚ùå Token error, attempting to fetch new one:', e);
                return await fetchNewToken();
            }
        }

        // Function to fetch image target source based on type
        async function fetchImageTargetSource(token, type) {
            const url = 'https://u2502-dev.dttt.vn/gwdevv5/csdldisan/v5/FileAR/GetFileARList';
            try {
                const res = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                });

                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`Failed to fetch FileARList: ${res.status} ${res.statusText} - ${errorText}`);
                }

                const result = await res.json();
                if (result.data && result.data.length > 0) {
                    const matchedFile = result.data.find(item => item.sharedDataUnixCode === type);
                    if (matchedFile) {
                        console.log(`Found image target URL for type "${type}": ${matchedFile.fileUrl}`);
                        return matchedFile.fileUrl;
                    } else {
                        console.warn(`No image target found for type "${type}". Using default.`);
                        return DEFAULT_IMAGE_TARGET_SRC; // Fallback to default
                    }
                }
                console.warn('FileARList data is empty. Using default image target.');
                return DEFAULT_IMAGE_TARGET_SRC; // Fallback to default
            } catch (error) {
                console.error('Error fetching image target source:', error);
                return DEFAULT_IMAGE_TARGET_SRC; // Fallback on error
            }
        }

        // This function is no longer used if we only rely on 'type' and fetch all models
        // async function fetchHienVatSingle(id, token) { /* ... */ }

        async function fetchHienVatList(token) {
            const url = "https://u2502-dev.dttt.vn/gwdevv5/csdldisan/v5/HienVat3D/GetHienVat3DList";

            try {
                const res = await fetch(url, {
                    method: "GET",
                    headers: {
                        Authorization: `Bearer ${token}`,
                    },
                });

                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`Failed to fetch HienVat list: ${res.status} ${res.statusText} - ${errorText}`);
                }

                const result = await res.json();
                if (result.data && result.data.length > 0) {
                    return result.data;
                }
                return [];
            } catch (error) {
                console.error("Error fetching HienVat list:", error);
                throw error;
            }
        }

        function updateProgress(percent) {
            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');
            const loadingMessage = document.getElementById('loading-message');

            if (percent > 0 && percent < 100) {
                progressContainer.style.display = 'block';
                progressFill.style.width = `${percent}%`;
                loadingMessage.textContent = `ƒêang t·∫£i m√¥ h√¨nh... ${Math.round(percent)}%`;
                loadingMessage.style.display = 'block'; // Ensure message is visible
            } else {
                progressContainer.style.display = 'none';
                loadingMessage.style.display = 'none'; // Hide message when done or not loading
            }
        }

        async function initializeARScene() {
            const loadingMessage = document.getElementById('loading-message');
            loadingMessage.textContent = "ƒêang t·∫£i d·ªØ li·ªáu AR...";
            loadingMessage.style.display = 'block'; // Ensure initial message is visible

            const urlParams = new URLSearchParams(window.location.search);
            const type = urlParams.get('type'); // Only get the 'type' parameter

            let currentImageTargetSrc = DEFAULT_IMAGE_TARGET_SRC;
            let hienVatDataArray = [];

            try {
                const token = await getValidToken();

                // Dynamically set IMAGE_TARGET_SRC based on 'type' parameter
                if (type) {
                    currentImageTargetSrc = await fetchImageTargetSource(token, type);
                } else {
                    loadingMessage.textContent = "L·ªói: Kh√¥ng c√≥ tham s·ªë 'type' ƒë∆∞·ª£c cung c·∫•p trong URL. Vui l√≤ng s·ª≠ d·ª•ng URL nh∆∞: /index.html?type=MIND-001";
                    return;
                }

                // Always fetch all HienVat3D models when 'type' is provided
                console.log("Fetching all HienVat items...");
                const fetchedList = await fetchHienVatList(token);
                hienVatDataArray = fetchedList.filter(data => data.model3dMobileJpg || data.model3dPcJpg);

                if (hienVatDataArray.length === 0) {
                    alert("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu m√¥ h√¨nh 3D h·ª£p l·ªá n√†o (c√≥ th·ªÉ do thi·∫øu m√¥ h√¨nh 3D).");
                    loadingMessage.textContent = "Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu m√¥ h√¨nh 3D.";
                    return;
                }

                loadingMessage.textContent = "ƒêang kh·ªüi t·∫°o c·∫£nh AR...";

                // Detect mobile device and adjust renderer settings
                const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                const scene = document.createElement('a-scene');
                // Set mindar-image attribute with the determined source
                scene.setAttribute('mindar-image', `imageTargetSrc: ${currentImageTargetSrc}; autoStart: true; showStats: false; uiLoading: no; uiScanning: no; uiError: no;`);
                scene.setAttribute('color-space', 'sRGB');

                // Optimize renderer settings for mobile
                const rendererSettings = isMobile
                    ? 'colorManagement: true, physicallyCorrectLights: false, antialias: false, powerPreference: default, precision: mediump'
                    : 'colorManagement: true, physicallyCorrectLights: true, antialias: true, powerPreference: high-performance, precision: highp';

                scene.setAttribute('renderer', rendererSettings);
                scene.setAttribute('vr-mode-ui', 'enabled: false');
                scene.setAttribute('device-orientation-permission-ui', 'enabled: false');
                scene.setAttribute('loading-screen', 'enabled: false');

                const camera = document.createElement('a-camera');
                camera.setAttribute('position', '0 0 0');
                camera.setAttribute('look-controls', 'enabled: false');
                camera.setAttribute('cursor', 'fuse: false; rayOrigin: mouse;');
                camera.setAttribute('raycaster', 'near: 10; far: 10000; objects: .clickable');
                scene.appendChild(camera);

                // Simplified lighting for mobile
                const ambientLight = document.createElement('a-light');
                ambientLight.setAttribute('type', 'ambient');
                ambientLight.setAttribute('color', '#FFFFFF');
                ambientLight.setAttribute('intensity', isMobile ? '0.8' : '0.6');
                scene.appendChild(ambientLight);

                if (!isMobile) {
                    const directionalLight = document.createElement('a-light');
                    directionalLight.setAttribute('type', 'directional');
                    directionalLight.setAttribute('position', '1 1 1');
                    directionalLight.setAttribute('color', '#FFFFFF');
                    directionalLight.setAttribute('intensity', '0.4');
                    scene.appendChild(directionalLight);
                }

                // --- TH√äM ENTITY TEST HTML-SHADER TR·ª∞C TI·∫æP V√ÄO SCENE ƒê·ªÇ DEBUG ---
                const testHtmlEntity = document.createElement('a-entity');
                testHtmlEntity.setAttribute('position', '0 0 -2'); // ƒê·∫∑t ·ªü v·ªã tr√≠ d·ªÖ th·∫•y, ph√≠a tr∆∞·ªõc camera
                testHtmlEntity.setAttribute('scale', '0.02 0.02 0.02'); // K√≠ch th∆∞·ªõc l·ªõn
                testHtmlEntity.setAttribute('look-at', '[camera]'); // Lu√¥n h∆∞·ªõng v·ªÅ camera
                testHtmlEntity.setAttribute('render-order', '99'); // ƒê·∫£m b·∫£o render tr√™n c√πng
                testHtmlEntity.setAttribute('html-shader', `
                    html: <div style="width: 400px; height: 150px; background-color: #00FFFF; color: #FF00FF; text-align: center; padding: 20px; font-size: 30px; font-family: sans-serif;">
                            TEST HTML-SHADER
                          </div>;
                    transparent: true;
                    shader: html;
                    targetWidth: 400;
                    targetHeight: 150;
                    debug: true;
                    side: double;
                    depthTest: false;
                `);
                scene.appendChild(testHtmlEntity);
                // --- K·∫æT TH√öC ENTITY TEST ---


                hienVatDataArray.forEach(hienVatData => {
                    // Prioritize model3dMobileJpg first, then model3dPcGlb as per original logic
                    const modelUrl = hienVatData.model3dMobileJpg || hienVatData.model3dPcGlb;
                    const targetIndex = hienVatData.stt - 1; // Assuming stt maps to targetIndex
                    const title = hienVatData.tenHienVat3D;
                    const description = hienVatData.gioiThieu;

                    const arTarget = document.createElement('a-entity');
                    arTarget.setAttribute('mindar-image-target', `targetIndex: ${targetIndex}`);

                    const portfolioPlane = document.createElement('a-plane');
                    portfolioPlane.setAttribute('class', 'clickable');
                    portfolioPlane.setAttribute('position', '0.8 0.2 0.01');
                    portfolioPlane.setAttribute('width', '0.8');
                    portfolioPlane.setAttribute('height', '1');
                    portfolioPlane.setAttribute('color', '#FFFFFF'); // Changed from 'transparent' to a valid color
                    portfolioPlane.setAttribute('opacity', '0.0');
                    portfolioPlane.setAttribute('animation__hover', 'property: scale; to: 1.05 1.05 1.05; startEvents: mouseenter; dur: 400');
                    portfolioPlane.setAttribute('animation__unhover', 'property: scale; to: 1 1 1; startEvents: mouseleave; dur: 400');
                    portfolioPlane.setAttribute('animation__float', 'property: position; to: 0.8 0.23 0.01; dir: alternate; loop: true; dur: 3000; easing: easeInOutSine');


                    const modelEntity = document.createElement('a-entity');
                    modelEntity.setAttribute('id', `model-${targetIndex}`);
                    modelEntity.setAttribute('class', 'model-entity clickable');
                    modelEntity.setAttribute('data-model-url', modelUrl);
                    modelEntity.setAttribute('data-loaded', 'false');
                    modelEntity.setAttribute('position', '0.8 0.2 0.02');
                    modelEntity.setAttribute('scale', '0.00001 0.00001 0.00001');
                    modelEntity.setAttribute('visible', 'false');
                    modelEntity.setAttribute('interactive-model', '');
                    modelEntity.setAttribute('lod-system', ''); // Apply LOD system

                    // Load model with progress tracking
                    arTarget.addEventListener('targetFound', async () => {
                        console.log(`Target ${targetIndex} found`);

                        if (modelEntity.getAttribute('data-loaded') === 'false') {
                            try {
                                // Show loading message and progress bar for this specific model
                                loadingMessage.textContent = `ƒêang t·∫£i m√¥ h√¨nh ${title}...`;
                                loadingMessage.style.display = 'block';
                                updateProgress(0);

                                await modelLoadingManager.loadModel(
                                    modelUrl,
                                    modelEntity,
                                    (progress) => {
                                        updateProgress(progress);
                                    }
                                );

                                modelEntity.setAttribute('data-loaded', 'true');
                                modelEntity.setAttribute('visible', 'true');

                                // Smooth scale animation
                                modelEntity.setAttribute('animation__scale',
                                    'property: scale; to: 0.0002 0.0002 0.0002; dur: 1000; easing: easeOutCubic');

                                // Hide loading indicators after model is loaded
                                loadingMessage.style.display = 'none';
                                updateProgress(100); // Set to 100 to hide progress bar

                                console.log(`Model ${title} loaded successfully from URL: ${modelUrl}`);
                            } catch (error) {
                                console.error(`Failed to load model ${title}:`, error);
                                loadingMessage.textContent = `L·ªói t·∫£i m√¥ h√¨nh ${title}`;
                                loadingMessage.style.display = 'block';
                                updateProgress(100); // Hide progress bar on error
                            }
                        } else {
                            modelEntity.setAttribute('visible', 'true');
                            loadingMessage.style.display = 'none';
                            updateProgress(100); // Hide progress bar if already loaded
                        }
                    });

                    arTarget.addEventListener('targetLost', () => {
                        console.log(`Target ${targetIndex} lost`);
                        modelEntity.setAttribute('visible', 'false');
                    });

                    // Info panel (s·ª≠ d·ª•ng a-entity v·ªõi html-shader tr·ª±c ti·∫øp)
                    const infoHtmlEntity = document.createElement('a-entity');
                    infoHtmlEntity.setAttribute('class', 'clickable'); // Gi·ªØ l·∫°i class clickable
                    infoHtmlEntity.setAttribute('position', '0 -0.65 0.01'); // V·ªã tr√≠ c·ªßa panel
                    infoHtmlEntity.setAttribute('width', '1'); // Chi·ªÅu r·ªông c·ªßa panel
                    infoHtmlEntity.setAttribute('height', '0.7'); // Chi·ªÅu cao c·ªßa panel
                    infoHtmlEntity.setAttribute('scale', '0.01 0.01 0.01'); // ƒê√£ tƒÉng scale ƒë√°ng k·ªÉ
                    infoHtmlEntity.setAttribute('look-at', '[camera]'); // Lu√¥n h∆∞·ªõng v·ªÅ camera
                    infoHtmlEntity.setAttribute('render-order', '1'); // ƒê·∫£m b·∫£o render sau c√°c ƒë·ªëi t∆∞·ª£ng kh√°c
                    infoHtmlEntity.setAttribute('html-shader', `
                        html: <div class="info-panel-content">
                                <h3>${title || 'TI√äU ƒê·ªÄ KH√îNG C√ì'}</h3>
                                <p>${description || 'M√î T·∫¢ KH√îNG C√ì: ƒê√¢y l√† vƒÉn b·∫£n ki·ªÉm tra ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªÉn th·ªã. N·∫øu b·∫°n th·∫•y d√≤ng n√†y, html-shader ƒëang ho·∫°t ƒë·ªông.'}</p>
                              </div>;
                        transparent: true;
                        shader: html;
                        targetWidth: 300; /* Chi·ªÅu r·ªông c·ªßa HTML content */
                        targetHeight: 250; /* ƒê√£ c·∫≠p nh·∫≠t chi·ªÅu cao ƒë·ªÉ kh·ªõp v·ªõi CSS */
                        debug: true; /* Th√™m thu·ªôc t√≠nh debug */
                        side: double; /* Render t·ª´ c·∫£ hai ph√≠a */
                        depthTest: false; /* T·∫Øt ki·ªÉm tra ƒë·ªô s√¢u ƒë·ªÉ lu√¥n hi·ªÉn th·ªã tr√™n c√πng */
                    `);
                    infoHtmlEntity.setAttribute('animation__hover', 'property: scale; to: 1.05 1.05 1.05; startEvents: mouseenter; dur: 400');
                    infoHtmlEntity.setAttribute('animation__unhover', 'property: scale; to: 1 1 1; startEvents: mouseleave; dur: 400');
                    infoHtmlEntity.setAttribute('animation__float', 'property: position; to: 0 -0.62 0.01; dir: alternate; loop: true; dur: 3000; easing: easeInOutSine');


                    // Re-added instructions text (s·ª≠ d·ª•ng a-entity v·ªõi html-shader)
                    const instructionsHtmlEntity = document.createElement('a-entity');
                    const instructions = isMobile
                        ? 'üëÜ K√©o di chuy·ªÉn ‚Ä¢ ü§è Zoom'
                        : 'üñ±Ô∏è K√©o di chuy·ªÉn ‚Ä¢ üîÑ Cu·ªôn chu·ªôt Zoom';

                    instructionsHtmlEntity.setAttribute('position', '0 -0.85 0.01'); // Adjusted position to be below info panel
                    instructionsHtmlEntity.setAttribute('scale', '0.01 0.01 0.01'); // ƒê√£ tƒÉng scale ƒë√°ng k·ªÉ
                    instructionsHtmlEntity.setAttribute('look-at', '[camera]'); // Lu√¥n h∆∞·ªõng v·ªÅ camera
                    instructionsHtmlEntity.setAttribute('render-order', '1'); // ƒê·∫£m b·∫£o render sau c√°c ƒë·ªëi t∆∞·ª£ng kh√°c
                    instructionsHtmlEntity.setAttribute('html-shader', `
                        html: <div class="instructions-text">${instructions}</div>;
                        transparent: true;
                        shader: html;
                        targetWidth: 300;
                        targetHeight: 50;
                        debug: true; /* Th√™m thu·ªôc t√≠nh debug */
                        side: double; /* Render t·ª´ c·∫£ hai ph√≠a */
                        depthTest: false; /* T·∫Øt ki·ªÉm tra ƒë·ªô s√¢u ƒë·ªÉ lu√¥n hi·ªÉn th·ªã tr√™n c√πng */
                    `);
                    arTarget.appendChild(instructionsHtmlEntity); // Append directly to arTarget


                    // Add a simple box behind the info panel to visualize its position
                    // debugBox n√†y s·∫Ω n·∫±m trong infoHtmlEntity, gi√∫p x√°c ƒë·ªãnh v·ªã tr√≠ c·ªßa n√≥
                    const debugBox = document.createElement('a-box');
                    debugBox.setAttribute('position', '0 0 0'); // V·ªã tr√≠ t∆∞∆°ng ƒë·ªëi v·ªõi infoHtmlEntity
                    debugBox.setAttribute('width', '0.3'); // Corresponds to targetWidth 300px at scale 0.01
                    debugBox.setAttribute('height', '0.25'); // Corresponds to targetHeight 250px at scale 0.01
                    debugBox.setAttribute('depth', '0.01');
                    debugBox.setAttribute('color', '#880088'); // M√†u t√≠m n·ªïi b·∫≠t
                    debugBox.setAttribute('opacity', '0.5');
                    debugBox.setAttribute('visible', 'true'); // ƒê·∫£m b·∫£o lu√¥n hi·ªÉn th·ªã
                    infoHtmlEntity.appendChild(debugBox); // ƒê·∫∑t h·ªôp n√†y l√†m con c·ªßa infoHtmlEntity ƒë·ªÉ n√≥ di chuy·ªÉn c√πng

                    // Add click interaction for portfolio plane
                    portfolioPlane.addEventListener('click', () => {
                        console.log(`Clicked on ${title}`);
                        if (window.DeviceMotionEvent) {
                            if (navigator.vibrate) {
                                navigator.vibrate(50);
                            }
                        }
                    });

                    // Assemble the AR target
                    arTarget.appendChild(portfolioPlane);
                    arTarget.appendChild(modelEntity);
                    arTarget.appendChild(infoHtmlEntity); // Append infoHtmlEntity (ƒë√£ g·ªôp)

                    scene.appendChild(arTarget);
                });

                // Scene ready handler
                scene.addEventListener('loaded', () => {
                    console.log('A-Frame scene loaded');
                    loadingMessage.style.display = 'none';
                    updateProgress(100); // Hide progress bar when scene is fully loaded
                });

                // Error handling
                scene.addEventListener('mindar-error', (event) => {
                    console.error('MindAR Error:', event.detail);
                    loadingMessage.textContent = 'L·ªói kh·ªüi t·∫°o AR. Vui l√≤ng th·ª≠ l·∫°i.';
                    loadingMessage.style.display = 'block';
                    updateProgress(100); // Hide progress bar on error
                });

                // Replace body content with scene
                const progressContainer = document.getElementById('progress-container');
                document.body.innerHTML = '';
                document.body.appendChild(loadingMessage);
                if (progressContainer) {
                    document.body.appendChild(progressContainer);
                }
                document.body.appendChild(scene);

                console.log(`AR Scene initialized with ${hienVatDataArray.length} models`);

            } catch (error) {
                console.error('Failed to initialize AR scene:', error);
                loadingMessage.textContent = `L·ªói: ${error.message}`;
                loadingMessage.style.display = 'block';

                // Show retry button
                const retryButton = document.createElement('button');
                retryButton.textContent = 'Th·ª≠ l·∫°i';
                retryButton.style.cssText = `
                position: absolute;
                top: 60%;
                left: 50%;
                transform: translate(-50%, -50%);
                padding: 12px 24px;
                background: #3498db;
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 16px;
                cursor: pointer;
                font-family: sans-serif;
            `;
                retryButton.addEventListener('click', () => {
                    window.location.reload();
                });
                document.body.appendChild(retryButton);
                updateProgress(100); // Hide progress bar on overall error
            }
        }

        // Performance monitoring
        function initPerformanceMonitoring() {
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (isMobile) {
                // Monitor memory usage on mobile
                let lastMemoryWarning = 0;
                setInterval(() => {
                    if (performance.memory) {
                        const memoryUsage = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
                        if (memoryUsage > 0.8 && Date.now() - lastMemoryWarning > 30000) {
                            console.warn('High memory usage detected:', Math.round(memoryUsage * 100) + '%');
                            lastMemoryWarning = Date.now();
                        }
                    }
                }, 5000);
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM loaded, initializing AR scene...');
            initPerformanceMonitoring();
            await initializeARScene();
        });

        // Handle page visibility changes for performance
        document.addEventListener('visibilitychange', () => {
            const scene = document.querySelector('a-scene');
            if (scene) {
                if (document.hidden) {
                    // Pause animations when page is hidden
                    scene.pause();
                } else {
                    // Resume when page is visible
                    scene.play();
                }
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            const scene = document.querySelector('a-scene');
            if (scene && scene.camera) {
                scene.camera.aspect = window.innerWidth / window.innerHeight;
                scene.camera.updateProjectionMatrix();
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            const scene = document.querySelector('a-scene');
            if (scene) {
                scene.destroy();
            }
        });

    </script>
</body>

</html>