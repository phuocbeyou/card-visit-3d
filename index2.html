<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
            font-size: 1.2em;
        }

        a-scene {
            display: block;
            width: 100%;
            height: 100%;
        }

        #loading-message::after {
            content: '';
            animation: ellipsis 1.2s infinite;
        }

        @keyframes ellipsis {
            0% {
                content: '.';
            }

            33% {
                content: '..';
            }

            66% {
                content: '...';
            }

            100% {
                content: '';
            }
        }

        .progress-bar {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 30px;
        }

        .progress-fill {
            height: 100%;
            background: #3498db;
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>

<body>
    <div id="loading-message">ƒêang t·∫£i d·ªØ li·ªáu AR...</div>
    <div id="progress-container" class="progress-bar" style="display: none;">
        <div id="progress-fill" class="progress-fill"></div>
    </div>

    <script>
        // Performance optimization component
        AFRAME.registerComponent('performance-optimizer', {
            init: function () {
                // Enable frustum culling
                this.el.object3D.frustumCulled = true;

                // Optimize material
                this.el.addEventListener('model-loaded', () => {
                    this.optimizeModel();
                });
            },

            optimizeModel: function () {
                const model = this.el.object3D;

                model.traverse((child) => {
                    if (child.isMesh) {
                        // Enable frustum culling for all meshes
                        child.frustumCulled = true;

                        // Optimize materials
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => this.optimizeMaterial(mat));
                            } else {
                                this.optimizeMaterial(child.material);
                            }
                        }

                        // Optimize geometry
                        if (child.geometry) {
                            child.geometry.computeBoundingBox();
                            child.geometry.computeBoundingSphere();
                        }
                    }
                });
            },

            optimizeMaterial: function (material) {
                // Reduce quality for mobile
                if (window.DeviceMotionEvent && /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                    material.precision = 'mediump';
                }

                // Enable efficient rendering
                material.alphaTest = 0.1;
                material.transparent = false;

                // Disable unnecessary features
                material.fog = false;

                // Use lower quality shadows on mobile
                if (material.receiveShadow) {
                    material.receiveShadow = false;
                }
                if (material.castShadow) {
                    material.castShadow = false;
                }
            }
        });

        // LOD (Level of Detail) component
        AFRAME.registerComponent('lod-system', {
            schema: {
                distances: { type: 'array', default: [5, 15, 30] },
                qualities: { type: 'array', default: ['high', 'medium', 'low'] }
            },

            init: function () {
                this.camera = document.querySelector('[camera]');
                this.lastDistance = 0;
                this.currentLOD = 'high';

                // Throttle distance checking
                this.checkDistance = this.throttle(this.checkDistance.bind(this), 200);
            },

            tick: function () {
                if (this.el.object3D.visible) {
                    this.checkDistance();
                }
            },

            checkDistance: function () {
                if (!this.camera) return;

                const distance = this.el.object3D.position.distanceTo(this.camera.object3D.position);

                if (Math.abs(distance - this.lastDistance) > 2) {
                    this.lastDistance = distance;
                    this.updateLOD(distance);
                }
            },

            updateLOD: function (distance) {
                let newLOD = 'high';

                if (distance > this.data.distances[2]) {
                    newLOD = 'low';
                } else if (distance > this.data.distances[1]) {
                    newLOD = 'medium';
                }

                if (newLOD !== this.currentLOD) {
                    this.currentLOD = newLOD;
                    this.applyLOD(newLOD);
                }
            },

            applyLOD: function (level) {
                const model = this.el.object3D;

                model.traverse((child) => {
                    if (child.isMesh && child.material) {
                        switch (level) {
                            case 'low':
                                child.material.precision = 'lowp';
                                child.visible = child.userData.isImportant !== false;
                                break;
                            case 'medium':
                                child.material.precision = 'mediump';
                                child.visible = true;
                                break;
                            case 'high':
                                child.material.precision = 'highp';
                                child.visible = true;
                                break;
                        }
                    }
                });
            },

            throttle: function (func, limit) {
                let inThrottle;
                return function () {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }
        });

        // Optimized interactive model component
        AFRAME.registerComponent('interactive-model', {
            schema: {
                minScale: { type: 'number', default: 0.0001 },
                maxScale: { type: 'number', default: 0.0005 },
                panSpeed: { type: 'number', default: 0.0008 },
                rotateSpeed: { type: 'number', default: 0.4 },
                zoomSpeed: { type: 'number', default: 0.00003 }
            },

            init: function () {
                this.isDragging = false;
                this.isPanning = false;
                this.lastX = 0;
                this.lastY = 0;

                // More aggressive throttling for mobile
                const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const throttleDelay = isMobile ? 32 : 16; // 30fps for mobile, 60fps for desktop

                this.throttledMouseMove = this.throttle(this.onMouseMove.bind(this), throttleDelay);

                this.onMouseDown = this.onMouseDown.bind(this);
                this.onMouseUp = this.onMouseUp.bind(this);
                this.onMouseWheel = this.onMouseWheel.bind(this);

                // Touch events for mobile
                this.onTouchStart = this.onTouchStart.bind(this);
                this.onTouchEnd = this.onTouchEnd.bind(this);
                this.onTouchMove = this.throttle(this.onTouchMove.bind(this), throttleDelay);

                this.el.addEventListener('mousedown', this.onMouseDown);
                this.el.addEventListener('mouseup', this.onMouseUp);
                this.el.addEventListener('mousemove', this.throttledMouseMove);
                this.el.addEventListener('wheel', this.onMouseWheel);

                // Touch events
                this.el.addEventListener('touchstart', this.onTouchStart);
                this.el.addEventListener('touchend', this.onTouchEnd);
                this.el.addEventListener('touchmove', this.onTouchMove);
            },

            throttle: function (func, limit) {
                let inThrottle;
                return function () {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            },

            onTouchStart: function (evt) {
                if (evt.touches.length === 1) {
                    this.isDragging = true;
                    this.lastX = evt.touches[0].clientX;
                    this.lastY = evt.touches[0].clientY;
                }
            },

            onTouchEnd: function () {
                this.isDragging = false;
                this.isPanning = false;
            },

            onTouchMove: function (evt) {
                if (!this.isDragging || evt.touches.length !== 1) return;

                evt.preventDefault();
                const touch = evt.touches[0];
                const deltaX = touch.clientX - this.lastX;
                const deltaY = touch.clientY - this.lastY;

                this.applyTransformation(deltaX, deltaY, false);

                this.lastX = touch.clientX;
                this.lastY = touch.clientY;
            },

            onMouseDown: function (evt) {
                this.isDragging = true;
                this.isPanning = evt.shiftKey;
                this.lastX = evt.clientX;
                this.lastY = evt.clientY;
            },

            onMouseUp: function () {
                this.isDragging = false;
                this.isPanning = false;
            },

            onMouseMove: function (evt) {
                if (!this.isDragging) return;

                const deltaX = evt.clientX - this.lastX;
                const deltaY = evt.clientY - this.lastY;

                this.applyTransformation(deltaX, deltaY, this.isPanning);

                this.lastX = evt.clientX;
                this.lastY = evt.clientY;
            },

            applyTransformation: function (deltaX, deltaY, isPanning) {
                if (isPanning) {
                    const currentPos = this.el.object3D.position;
                    currentPos.x += deltaX * this.data.panSpeed;
                    currentPos.y -= deltaY * this.data.panSpeed;

                    // THAY ƒê·ªîI: ƒêi·ªÅu ch·ªânh gi·ªõi h·∫°n pan ƒë·ªÉ ph√π h·ª£p v·ªõi v·ªã tr√≠ m·ªõi (b√™n ph·∫£i)
                    const parentWidth = 0.6; // Gi·∫£m t·ª´ 0.7 xu·ªëng 0.6
                    const parentHeight = 0.9;
                    const modelScale = this.el.object3D.scale.x;
                    const modelHalfSize = modelScale * 15;

                    // ƒêi·ªÅu ch·ªânh offset ƒë·ªÉ model c√≥ th·ªÉ di chuy·ªÉn trong v√πng b√™n ph·∫£i
                    const clampX = Math.max(0, (parentWidth / 2) - modelHalfSize);
                    const clampY = Math.max(0, (parentHeight / 2) - modelHalfSize);

                    // THAY ƒê·ªîI: Th√™m offset ƒë·ªÉ gi·ªõi h·∫°n pan trong v√πng b√™n ph·∫£i
                    const offsetX = 0.2; // Offset ƒë·ªÉ gi·ªØ model ·ªü b√™n ph·∫£i
                    currentPos.x = Math.max(offsetX - clampX, Math.min(offsetX + clampX, currentPos.x));
                    currentPos.y = Math.max(-clampY, Math.min(clampY, currentPos.y));
                } else {
                    const rotation = this.el.object3D.rotation;
                    rotation.y += THREE.MathUtils.degToRad(deltaX * this.data.rotateSpeed);
                    rotation.x += THREE.MathUtils.degToRad(deltaY * this.data.rotateSpeed);
                }
            },

            onMouseWheel: function (evt) {
                evt.preventDefault();

                let newScale = this.el.object3D.scale.x - evt.deltaY * this.data.zoomSpeed;
                newScale = Math.max(this.data.minScale, Math.min(this.data.maxScale, newScale));
                this.el.object3D.scale.set(newScale, newScale, newScale);
            },

            remove: function () {
                this.el.removeEventListener('mousedown', this.onMouseDown);
                this.el.removeEventListener('mouseup', this.onMouseUp);
                this.el.removeEventListener('mousemove', this.throttledMouseMove);
                this.el.removeEventListener('wheel', this.onMouseWheel);
                this.el.removeEventListener('touchstart', this.onTouchStart);
                this.el.removeEventListener('touchend', this.onTouchEnd);
                this.el.removeEventListener('touchmove', this.onTouchMove);
            }
        });

        // Model loading manager with progress
        class ModelLoadingManager {
            constructor() {
                this.loadingQueue = [];
                this.maxConcurrentLoads = 2; // Limit concurrent loads
                this.activeLoads = 0;
                this.cache = new Map();
            }

            async loadModel(url, element, progressCallback) {
                // Check cache first
                if (this.cache.has(url)) {
                    const cachedModel = this.cache.get(url);
                    element.setObject3D('mesh', cachedModel.clone());
                    if (progressCallback) progressCallback(100);
                    return;
                }

                return new Promise((resolve, reject) => {
                    this.loadingQueue.push({
                        url,
                        element,
                        progressCallback,
                        resolve,
                        reject
                    });

                    this.processQueue();
                });
            }

            async processQueue() {
                if (this.activeLoads >= this.maxConcurrentLoads || this.loadingQueue.length === 0) {
                    return;
                }

                const loadTask = this.loadingQueue.shift();
                this.activeLoads++;

                try {
                    await this.performLoad(loadTask);
                } catch (error) {
                    loadTask.reject(error);
                } finally {
                    this.activeLoads--;
                    this.processQueue(); // Process next in queue
                }
            }

            async performLoad(loadTask) {
                const { url, element, progressCallback, resolve, reject } = loadTask;

                const loader = new THREE.GLTFLoader();

                // Add Draco compression support for smaller files
                if (typeof THREE.DRACOLoader !== 'undefined') {
                    const dracoLoader = new THREE.DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                    loader.setDRACOLoader(dracoLoader);
                }

                loader.load(
                    url,
                    (gltf) => {
                        // Optimize the loaded model
                        this.optimizeLoadedModel(gltf.scene);

                        // Cache the model
                        this.cache.set(url, gltf.scene);

                        // Set the model
                        element.setObject3D('mesh', gltf.scene);

                        if (progressCallback) progressCallback(100);
                        resolve(gltf);
                    },
                    (progress) => {
                        if (progressCallback && progress.lengthComputable) {
                            const percentComplete = (progress.loaded / progress.total) * 100;
                            progressCallback(percentComplete);
                        }
                    },
                    (error) => {
                        console.error('Model loading error:', error);
                        reject(error);
                    }
                );
            }

            optimizeLoadedModel(scene) {
                scene.traverse((child) => {
                    if (child.isMesh) {
                        // Enable frustum culling
                        child.frustumCulled = true;

                        // Optimize geometry
                        if (child.geometry) {
                            child.geometry.computeBoundingBox();
                            child.geometry.computeBoundingSphere();

                            // Remove unnecessary vertex attributes for mobile
                            if (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                                if (child.geometry.attributes.uv2) {
                                    delete child.geometry.attributes.uv2;
                                }
                            }
                        }

                        // Optimize materials
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => this.optimizeMaterialForMobile(mat));
                            } else {
                                this.optimizeMaterialForMobile(child.material);
                            }
                        }
                    }
                });
            }

            optimizeMaterialForMobile(material) {
                if (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                    material.precision = 'mediump';

                    // Reduce texture quality on mobile
                    if (material.map) {
                        material.map.generateMipmaps = true;
                        material.map.minFilter = THREE.LinearMipmapLinearFilter;
                        material.map.magFilter = THREE.LinearFilter;
                    }

                    // Disable expensive material features
                    material.fog = false;
                    material.receiveShadow = false;
                    material.castShadow = false;
                }
            }
        }

        const modelLoadingManager = new ModelLoadingManager();

        // API Configuration
        const TOKEN_KEY = 'access_token';
        const EXPIRES_KEY = 'expires_in';
        const DATE_SAVE_KEY = 'date_save';
        const IMAGE_TARGET_SRC = 'https://u2502-dev.dttt.vn/static/assets//app/wwwroot/uploads/2025/6/13/1b387430-7f76-44a4-bdb8-5feb2f0e2d9f_dataAPPAr.mind';

        async function fetchNewToken() {
            const payload = new URLSearchParams({
                grant_type: 'password',
                scope: 'password',
                client_id: 'password',
                client_secret: '083c426a-a3f7-f4ea-a70a-290c401b558f',
                username: 'user3d',
                password: '123456a@A'
            });

            const res = await fetch('https://u2502-dev-sso.dttt.vn/connect/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: payload.toString()
            });

            if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Token fetch failed: ${res.status} ${res.statusText} - ${errorText}`);
            }

            const data = await res.json();
            localStorage.setItem(TOKEN_KEY, data.access_token);
            localStorage.setItem(EXPIRES_KEY, String(data.expires_in));
            localStorage.setItem(DATE_SAVE_KEY, String(Date.now()));
            return data.access_token;
        }

        function isTokenExpired() {
            const token = localStorage.getItem(TOKEN_KEY);
            const expiresIn = parseInt(localStorage.getItem(EXPIRES_KEY) || '0');
            const dateSaved = parseInt(localStorage.getItem(DATE_SAVE_KEY) || '0');
            if (!token || !expiresIn || !dateSaved) return true;
            const now = Date.now();
            const buffer = 5 * 24 * 60 * 60 * 1000;
            return now - dateSaved >= (expiresIn * 1000 - buffer);
        }

        async function getValidToken() {
            try {
                if (isTokenExpired()) {
                    console.log('üîÑ Token expired or missing, fetching new one...');
                    return await fetchNewToken();
                }
                console.log('‚úÖ Using saved token.');
                return localStorage.getItem(TOKEN_KEY) || "";
            } catch (e) {
                console.error('‚ùå Token error, attempting to fetch new one:', e);
                return await fetchNewToken();
            }
        }

        async function fetchHienVatSingle(id, token) {
            const url = "https://u2502-dev.dttt.vn/gwdevv5/csdldisan/v5/HienVat3D/GetData/FilterByHienVat";
            const payload = {
                filters: [
                    {
                        valueIsField: false,
                        filters: [],
                        stringCompareOption: 0,
                        field: "id",
                        operator: "eq",
                        value: `"${id}"`,
                    },
                ],
                sorts: [
                    {
                        field: "thuTu",
                        dir: 1,
                    },
                ],
                includes: [],
                pageInfo: {
                    page: 1,
                    pageSize: 15,
                },
            };

            try {
                const res = await fetch(url, {
                    method: "POST",
                    headers: {
                        Authorization: `Bearer ${token}`,
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(payload),
                });

                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`Failed to fetch HienVat data: ${res.status} ${res.statusText} - ${errorText}`);
                }

                const result = await res.json();
                if (result.data && result.data.length > 0) {
                    return result.data[0];
                }
                return null;
            } catch (error) {
                console.error("Error fetching HienVat data:", error);
                throw error;
            }
        }

        async function fetchHienVatList(token) {
            const url = "https://u2502-dev.dttt.vn/gwdevv5/csdldisan/v5/HienVat3D/GetHienVat3DList";

            try {
                const res = await fetch(url, {
                    method: "GET",
                    headers: {
                        Authorization: `Bearer ${token}`,
                    },
                });

                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`Failed to fetch HienVat list: ${res.status} ${res.statusText} - ${errorText}`);
                }

                const result = await res.json();
                if (result.data && result.data.length > 0) {
                    return result.data;
                }
                return [];
            } catch (error) {
                console.error("Error fetching HienVat list:", error);
                throw error;
            }
        }

        function updateProgress(percent) {
            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');

            if (percent > 0) {
                progressContainer.style.display = 'block';
                progressFill.style.width = `${percent}%`;
            } else {
                progressContainer.style.display = 'none';
            }
        }

        async function initializeARScene() {
            const loadingMessage = document.getElementById('loading-message');
            loadingMessage.textContent = "ƒêang t·∫£i d·ªØ li·ªáu AR...";

            const urlParams = new URLSearchParams(window.location.search);
            const id = urlParams.get('id');
            const mutil = urlParams.get('mutil') === 'true';

            let hienVatDataArray = [];

            try {
                const token = await getValidToken();

                if (mutil) {
                    console.log("Fetching multiple HienVat items...");
                    const fetchedList = await fetchHienVatList(token);
                    hienVatDataArray = fetchedList.filter(data => data.model3dPcJpg || data.model3dPcGlb);

                    if (hienVatDataArray.length === 0) {
                        alert("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu AR h·ª£p l·ªá n√†o trong danh s√°ch (c√≥ th·ªÉ do thi·∫øu m√¥ h√¨nh 3D).");
                        loadingMessage.textContent = "Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu AR.";
                        return;
                    }
                } else {
                    if (!id) {
                        loadingMessage.textContent = "L·ªói: Kh√¥ng c√≥ ID ƒë∆∞·ª£c cung c·∫•p trong URL. Vui l√≤ng s·ª≠ d·ª•ng URL nh∆∞: /index.html?id=1f0fdcaf-c992-4817-b095-1fb2d2b5cbd0";
                        return;
                    }
                    console.log(`Fetching single HienVat item for ID: ${id}`);
                    const singleData = await fetchHienVatSingle(id, token);
                    if (singleData && (singleData.model3dPcJpg || singleData.model3dPcGlb)) {
                        hienVatDataArray.push(singleData);
                    } else {
                        alert("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho ID n√†y ho·∫∑c m√¥ h√¨nh 3D b·ªã thi·∫øu. Vui l√≤ng ki·ªÉm tra l·∫°i ID.");
                        loadingMessage.textContent = "Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu AR.";
                        return;
                    }
                }

                loadingMessage.textContent = "ƒêang kh·ªüi t·∫°o c·∫£nh AR...";

                // Detect mobile device and adjust renderer settings
                const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                const scene = document.createElement('a-scene');
                scene.setAttribute('mindar-image', `imageTargetSrc: ${IMAGE_TARGET_SRC}; autoStart: true; showStats: false; uiLoading: no; uiScanning: no; uiError: no;`);
                scene.setAttribute('color-space', 'sRGB');

                // Optimize renderer settings for mobile
                const rendererSettings = isMobile
                    ? 'colorManagement: true, physicallyCorrectLights: false, antialias: false, powerPreference: default, precision: mediump'
                    : 'colorManagement: true, physicallyCorrectLights: true, antialias: true, powerPreference: high-performance, precision: highp';

                scene.setAttribute('renderer', rendererSettings);
                scene.setAttribute('vr-mode-ui', 'enabled: false');
                scene.setAttribute('device-orientation-permission-ui', 'enabled: false');
                scene.setAttribute('loading-screen', 'enabled: false');

                const camera = document.createElement('a-camera');
                camera.setAttribute('position', '0 0 0');
                camera.setAttribute('look-controls', 'enabled: false');
                camera.setAttribute('cursor', 'fuse: false; rayOrigin: mouse;');
                camera.setAttribute('raycaster', 'near: 10; far: 10000; objects: .clickable');
                scene.appendChild(camera);

                // Simplified lighting for mobile
                const ambientLight = document.createElement('a-light');
                ambientLight.setAttribute('type', 'ambient');
                ambientLight.setAttribute('color', '#FFFFFF');
                ambientLight.setAttribute('intensity', isMobile ? '0.8' : '0.6');
                scene.appendChild(ambientLight);

                if (!isMobile) {
                    const directionalLight = document.createElement('a-light');
                    directionalLight.setAttribute('type', 'directional');
                    directionalLight.setAttribute('position', '1 1 1');
                    directionalLight.setAttribute('color', '#FFFFFF');
                    directionalLight.setAttribute('intensity', '0.4');
                    scene.appendChild(directionalLight);
                }

                hienVatDataArray.forEach(hienVatData => {
                    const modelUrl = hienVatData.model3dPcJpg || hienVatData.model3dPcGlb;
                    const targetIndex = hienVatData.stt - 1;
                    const title = hienVatData.tenHienVat3D;
                    const description = hienVatData.gioiThieu;

                    const arTarget = document.createElement('a-entity');
                    arTarget.setAttribute('mindar-image-target', `targetIndex: ${targetIndex}`);

                    // 2. Thay ƒë·ªïi v·ªã tr√≠ portfolioPlane ƒë·ªÉ ph√π h·ª£p v·ªõi layout m·ªõi
                    const portfolioPlane = document.createElement('a-plane');
                    portfolioPlane.setAttribute('class', 'clickable');
                    // THAY ƒê·ªîI: ƒêi·ªÅu ch·ªânh v·ªã tr√≠ portfolio plane
                    portfolioPlane.setAttribute('position', '0.8 0.2 0.01'); // C·∫≠p nh·∫≠t theo v·ªã tr√≠ model m·ªõi
                    portfolioPlane.setAttribute('width', '0.8'); // Gi·∫£m k√≠ch th∆∞·ªõc t·ª´ '1' xu·ªëng '0.8'
                    portfolioPlane.setAttribute('height', '1'); // Gi·∫£m k√≠ch th∆∞·ªõc t·ª´ '1.2' xu·ªëng '1'
                    portfolioPlane.setAttribute('color', 'transparent');
                    portfolioPlane.setAttribute('opacity', '0.0');

                    // 3. Thay ƒë·ªïi animation cho portfolioPlane
                    if (!isMobile) {
                        portfolioPlane.setAttribute('animation__hover', 'property: scale; to: 1.05 1.05 1.05; startEvents: mouseenter; dur: 400');
                        portfolioPlane.setAttribute('animation__unhover', 'property: scale; to: 1 1 1; startEvents: mouseleave; dur: 400');
                        // THAY ƒê·ªîI: ƒêi·ªÅu ch·ªânh animation float ƒë·ªÉ ph√π h·ª£p v·ªõi v·ªã tr√≠ m·ªõi
                        portfolioPlane.setAttribute('animation__float', 'property: position; to: 0.8 0.23 0.01; dir: alternate; loop: true; dur: 3000; easing: easeInOutSine');
                    }


                    // 1. Thay ƒë·ªïi v·ªã tr√≠ model 3D - di chuy·ªÉn sang b√™n ph·∫£i xa h∆°n
                    const modelEntity = document.createElement('a-entity');
                    modelEntity.setAttribute('id', `model-${targetIndex}`);
                    modelEntity.setAttribute('class', 'model-entity clickable');
                    modelEntity.setAttribute('data-model-url', modelUrl);
                    modelEntity.setAttribute('data-loaded', 'false');
                    // THAY ƒê·ªîI: Di chuy·ªÉn model sang b√™n ph·∫£i xa h∆°n
                    modelEntity.setAttribute('position', '0.8 0.2 0.02'); // Di chuy·ªÉn xa h∆°n sang ph·∫£i
                    modelEntity.setAttribute('scale', '0.00001 0.00001 0.00001');
                    modelEntity.setAttribute('visible', 'false');
                    modelEntity.setAttribute('interactive-model', '');
                    modelEntity.setAttribute('performance-optimizer', '');
                    modelEntity.setAttribute('lod-system', '');

                    // Load model with progress tracking
                    arTarget.addEventListener('targetFound', async () => {
                        console.log(`Target ${targetIndex} found`);

                        if (modelEntity.getAttribute('data-loaded') === 'false') {
                            try {
                                loadingMessage.textContent = `ƒêang t·∫£i m√¥ h√¨nh ${title}...`;
                                updateProgress(0);

                                await modelLoadingManager.loadModel(
                                    modelUrl,
                                    modelEntity,
                                    (progress) => {
                                        updateProgress(progress);
                                        loadingMessage.textContent = `ƒêang t·∫£i m√¥ h√¨nh ${title}... ${Math.round(progress)}%`;
                                    }
                                );

                                modelEntity.setAttribute('data-loaded', 'true');
                                modelEntity.setAttribute('visible', 'true');

                                // Smooth scale animation
                                modelEntity.setAttribute('animation__scale',
                                    'property: scale; to: 0.0002 0.0002 0.0002; dur: 1000; easing: easeOutCubic');

                                loadingMessage.style.display = 'none';
                                updateProgress(0);

                                console.log(`Model ${title} loaded successfully`);
                            } catch (error) {
                                console.error(`Failed to load model ${title}:`, error);
                                loadingMessage.textContent = `L·ªói t·∫£i m√¥ h√¨nh ${title}`;
                            }
                        } else {
                            modelEntity.setAttribute('visible', 'true');
                            loadingMessage.style.display = 'none';
                        }
                    });

                    arTarget.addEventListener('targetLost', () => {
                        console.log(`Target ${targetIndex} lost`);
                        modelEntity.setAttribute('visible', 'false');
                    });

                    // 4. Thay ƒë·ªïi v·ªã tr√≠ Info panel - UI ƒë·∫πp h∆°n v·ªõi gradient v√† bo g√≥c
                    const infoPanel = document.createElement('a-plane');
                    // THAY ƒê·ªîI: Di chuy·ªÉn info panel xu·ªëng d∆∞·ªõi v√† sang tr√°i, l√†m ƒë·∫πp UI
                    infoPanel.setAttribute('position', '-0.4 -0.6 0.01');
                    infoPanel.setAttribute('width', '1.4'); // TƒÉng chi·ªÅu r·ªông
                    infoPanel.setAttribute('height', '0.6'); // TƒÉng chi·ªÅu cao
                    infoPanel.setAttribute('color', '#2c3e50'); // M√†u xanh ƒë·∫≠m ƒë·∫πp h∆°n
                    infoPanel.setAttribute('opacity', '0.92'); // TƒÉng ƒë·ªô trong su·ªët
                    infoPanel.setAttribute('material', 'shader: flat; side: double'); // Th√™m side: double
                    infoPanel.setAttribute('geometry', 'primitive: plane; width: 1.4; height: 0.6'); // ƒê

                    // 5. Thay ƒë·ªïi v·ªã tr√≠ Title text - UI ƒë·∫πp h∆°n
                    const titleText = document.createElement('a-text');
                    titleText.setAttribute('value', title);
                    // THAY ƒê·ªîI: ƒêi·ªÅu ch·ªânh v·ªã tr√≠ v√† style title text ƒë·ªÉ ƒë·∫πp h∆°n
                    titleText.setAttribute('position', '-0.4 -0.42 0.02');
                    titleText.setAttribute('align', 'center');
                    titleText.setAttribute('width', '4.5'); // TƒÉng k√≠ch th∆∞·ªõc font
                    titleText.setAttribute('color', '#ffffff');
                    titleText.setAttribute('font', 'roboto');
                    titleText.setAttribute('wrap-count', '28');
                    titleText.setAttribute('letter-spacing', '1'); // Th√™m letter spacing



                    // Fix 1: Update Description text section - replace the existing descText creation code
                    const descText = document.createElement('a-text');
                    // THAY ƒê·ªîI: Gi·ªõi h·∫°n m√¥ t·∫£ ng·∫Øn h∆°n cho mobile v√† ƒëi·ªÅu ch·ªânh font size ƒë·ªÉ v·ª´a v·∫∑n
                    const isMobileDevice = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    const maxDescLength = isMobileDevice ? 50 : 70; // Mobile: 50, Desktop: 70 k√Ω t·ª±
                    const shortDesc = description && description.length > maxDescLength
                        ? description.substring(0, maxDescLength) + '...'
                        : (description || 'M√¥ t·∫£ hi·ªán v·∫≠t 3D');
                    descText.setAttribute('value', shortDesc);
                    // THAY ƒê·ªîI: ƒêi·ªÅu ch·ªânh v·ªã tr√≠ v√† gi·∫£m k√≠ch th∆∞·ªõc font ƒë·ªÉ text kh√¥ng tr√†n, t·ªëi ∆∞u cho mobile
                    descText.setAttribute('position', '-0.4 -0.62 0.02');
                    descText.setAttribute('align', 'center');
                    descText.setAttribute('width', isMobileDevice ? '1.8' : '2.2'); // Mobile: 1.8, Desktop: 2.2
                    descText.setAttribute('color', '#ecf0f1');
                    descText.setAttribute('font', 'roboto');
                    descText.setAttribute('wrap-count', isMobileDevice ? '20' : '25'); // Mobile: 20, Desktop: 25

                    // Fix 2: Update Instructions text section - replace the existing instructionsText creation code  
                    const instructionsText = document.createElement('a-text');
                    const instructions = isMobileDevice
                        ? 'üëÜ Xoay ‚Ä¢ ü§è Zoom'  // R√∫t ng·∫Øn t·ªëi ƒëa cho mobile
                        : 'üñ±Ô∏è K√©o xoay ‚Ä¢ ‚áß+k√©o di chuy·ªÉn ‚Ä¢ üîÑ Zoom'; // Desktop gi·ªØ nguy√™n

                    instructionsText.setAttribute('value', instructions);
                    // THAY ƒê·ªîI: ƒêi·ªÅu ch·ªânh ƒë·ªÉ instructions text v·ª´a v·∫∑n, t·ªëi ∆∞u cho mobile
                    instructionsText.setAttribute('position', '-0.4 -0.78 0.02');
                    instructionsText.setAttribute('align', 'center');
                    instructionsText.setAttribute('width', isMobileDevice ? '1.6' : '2.0'); // Mobile: 1.6, Desktop: 2.0  
                    instructionsText.setAttribute('color', '#3498db');
                    instructionsText.setAttribute('font', 'roboto');
                    instructionsText.setAttribute('wrap-count', isMobileDevice ? '18' : '22'); // Mobi


                    // Add click interaction for portfolio plane
                    portfolioPlane.addEventListener('click', () => {
                        console.log(`Clicked on ${title}`);
                        // Add any additional click interactions here
                        if (window.DeviceMotionEvent) {
                            // Haptic feedback on mobile
                            if (navigator.vibrate) {
                                navigator.vibrate(50);
                            }
                        }
                    });

                    // Assemble the AR target
                    arTarget.appendChild(portfolioPlane);
                    arTarget.appendChild(modelEntity);
                    arTarget.appendChild(infoPanel);
                    arTarget.appendChild(titleText);
                    arTarget.appendChild(descText);
                    arTarget.appendChild(instructionsText);

                    scene.appendChild(arTarget);
                });

                // Scene ready handler
                scene.addEventListener('loaded', () => {
                    console.log('A-Frame scene loaded');
                    loadingMessage.style.display = 'none';
                    updateProgress(0);
                });

                // Error handling
                scene.addEventListener('mindar-error', (event) => {
                    console.error('MindAR Error:', event.detail);
                    loadingMessage.textContent = 'L·ªói kh·ªüi t·∫°o AR. Vui l√≤ng th·ª≠ l·∫°i.';
                });

                // Replace body content with scene
                const progressContainer = document.getElementById('progress-container');
                document.body.innerHTML = '';
                document.body.appendChild(loadingMessage);
                if (progressContainer) {
                    document.body.appendChild(progressContainer);
                }
                document.body.appendChild(scene);

                console.log(`AR Scene initialized with ${hienVatDataArray.length} models`);

            } catch (error) {
                console.error('Failed to initialize AR scene:', error);
                loadingMessage.textContent = `L·ªói: ${error.message}`;

                // Show retry button
                const retryButton = document.createElement('button');
                retryButton.textContent = 'Th·ª≠ l·∫°i';
                retryButton.style.cssText = `
                    position: absolute;
                    top: 60%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    padding: 12px 24px;
                    background: #3498db;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-size: 16px;
                    cursor: pointer;
                    font-family: sans-serif;
                `;
                retryButton.addEventListener('click', () => {
                    window.location.reload();
                });
                document.body.appendChild(retryButton);
            }
        }

        // Performance monitoring
        function initPerformanceMonitoring() {
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (isMobile) {
                // Monitor memory usage on mobile
                let lastMemoryWarning = 0;
                setInterval(() => {
                    if (performance.memory) {
                        const memoryUsage = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
                        if (memoryUsage > 0.8 && Date.now() - lastMemoryWarning > 30000) {
                            console.warn('High memory usage detected:', Math.round(memoryUsage * 100) + '%');
                            lastMemoryWarning = Date.now();
                        }
                    }
                }, 5000);
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM loaded, initializing AR scene...');
            initPerformanceMonitoring();
            await initializeARScene();
        });

        // Handle page visibility changes for performance
        document.addEventListener('visibilitychange', () => {
            const scene = document.querySelector('a-scene');
            if (scene) {
                if (document.hidden) {
                    // Pause animations when page is hidden
                    scene.pause();
                } else {
                    // Resume when page is visible
                    scene.play();
                }
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            const scene = document.querySelector('a-scene');
            if (scene && scene.camera) {
                scene.camera.aspect = window.innerWidth / window.innerHeight;
                scene.camera.updateProjectionMatrix();
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            const scene = document.querySelector('a-scene');
            if (scene) {
                scene.destroy();
            }
        });

    </script>
</body>

</html>